#!/bin/bash

set -e

export KUBEVIRT_PROVIDER=${KUBEVIRT_PROVIDER:-k8s-1.21}
export KUBEVIRTCI_TAG=${KUBEVIRTCI_TAG:-2110251848-8198e9c}
export KUBECONFIG=$(cluster-up/cluster-up/kubeconfig.sh)
export KUBEVIRT_DEPLOY_PROMETHEUS=false
export KUBEVIRT_DEPLOY_CDI=false
export KUBEVIRT_NUM_NODES=${KUBEVIRT_NUM_NODES:-1}
export KUBEVIRT_MEMORY_SIZE=${KUBEVIRT_MEMORY_SIZE:-15360M}
export KUBEVIRT_DEPLOY_CDI="true"
export KUBEVIRT_STORAGE="rook-ceph-default"

_default_bin_path=./hack/tools/bin
_default_tmp_path=./hack/tools/bin/tmp
_default_clusterctl_path=./hack/tools/bin/clusterctl
_default_virtctl_path=./hack/tools/bin/virtctl

export CLUSTERCTL_PATH=${CLUSTERCTL_PATH:-${_default_clusterctl_path}}
export TENANT_CLUSTER_NAME=${TENANT_CLUSTER_NAME:-kvcluster}
export TENANT_CLUSTER_NAMESPACE=${TENANT_CLUSTER_NAMESPACE:-kvcluster}

_kubectl=cluster-up/cluster-up/kubectl.sh
_ssh_infra=cluster-up/cluster-up/ssh.sh

_action=$1
shift


function kubevirtci::usage() {
	echo "Usage:

	./kubevirtci <cammand>

	Commands:

	  up                                Start a cluster with kubevirt, cert-manager and capi
	  sync                              Build and deploy current capk
	  down                              Destroy the cluster
	  refresh                           Build current capk and trigger creating new capk pods

	  kubeconfig                        Return the kubeconfig of the cluster
	  kubectl <kubectl options>         Interact with the cluster
	  virtctl <virtctl options>         Run virtctl commands against the cluster
	  clusterctl <clusterctl options>   Run clusterctl commands against the cluster

	  ssh-infra <node name>             SSH into one of the infra nodes (like node01)
	  ssh-tenant <vmi> [vmi namespace]  SSH into one of the guest nodes
	  create-cluster                    Create new kubernetes tenant cluster
	  kubectl-tenant <kubectl options>  Interact with the tenant cluster

	  help                              Print usage
	"
}

function kubevirtci::kubeconfig() {
	cluster-up/cluster-up/kubeconfig.sh
}

function kubevirtci::fetch_kubevirtci() {
	[[ -d cluster-up ]] || git clone https://github.com/kubevirt/kubevirtci.git cluster-up
	(cd cluster-up && git checkout ${KUBEVIRTCI_TAG} > /dev/null)
	mkdir -p ./hack/tools/bin/
	if [ ! -f "${_default_clusterctl_path}" ]; then
		echo >&2 "Downloading clusterctl ..."
		curl -L https://github.com/kubernetes-sigs/cluster-api/releases/download/v1.0.0/clusterctl-linux-amd64 -o ${_default_clusterctl_path}
		chmod u+x ${_default_clusterctl_path}
	fi
	if [ ! -f "${_default_virtctl_path}" ]; then
		echo >&2 "Downloading virtctl ..."
		LATEST=$(curl -L https://storage.googleapis.com/kubevirt-prow/devel/release/kubevirt/kubevirt/stable.txt)
		curl -L https://github.com/kubevirt/kubevirt/releases/download/${LATEST}/virtctl-${LATEST}-linux-amd64 -o ${_default_virtctl_path}
		chmod u+x ${_default_virtctl_path}
	fi
}

function kubevirtci::up() {
	make cluster-up -C cluster-up
	export KUBECONFIG=$(cluster-up/cluster-up/kubeconfig.sh)
	echo "installing kubevirt..."
	LATEST=$(curl -L https://storage.googleapis.com/kubevirt-prow/devel/release/kubevirt/kubevirt/stable.txt)
	${_kubectl} apply -f https://github.com/kubevirt/kubevirt/releases/download/${LATEST}/kubevirt-operator.yaml
	${_kubectl} apply -f https://github.com/kubevirt/kubevirt/releases/download/${LATEST}/kubevirt-cr.yaml
	echo "installing capi..."

	cat << EOF > ${_default_bin_path}/clusterctl_config.yaml
---
cert-manager:
  url: "https://github.com/cert-manager/cert-manager/releases/latest/cert-manager.yaml"
EOF
	$CLUSTERCTL_PATH init -v 4 --config=${_default_bin_path}/clusterctl_config.yaml
	echo "waiting for kubevirt to become ready, this can take a few minutes. You can safely abort this step, the cluster is ready ..."
	${_kubectl} -n kubevirt wait kv kubevirt --for condition=Available --timeout=5m
}

function kubevirtci::down() {
	make cluster-down -C cluster-up
}

function kubevirtci::build() {
	export REGISTRY="127.0.0.1:$(cluster-up/cluster-up/cli.sh ports registry)"
	make docker-build
	make docker-push
}

function kubevirtci::ssh_tenant() {
	vmi_name=$1
	vmi_namespace=${2:-$TENANT_CLUSTER_NAMESPACE}

	mkdir -p $_default_tmp_path

	echo "vmi $vmi_name namespace $vmi_namespace"

	${_kubectl} get secret -n e2e-test-create-cluster-87mlkk kvcluster-ssh-keys -o jsonpath='{.data}' | grep key | awk -F '"' '{print $4}' | base64 -d > ${_default_tmp_path}/key.pem

	chmod 600 ${_default_tmp_path}/key.pem

	ssh -o IdentitiesOnly=yes -o "ProxyCommand=$_default_virtctl_path port-forward --stdio=true $vmi_name.$vmi_namespace 22" capk@$vmi_name.$vmi_namespace -i ${_default_tmp_path}/key.pem

	rm ${_default_tmp_path}/key.pem
}

function kubevirtci::refresh() {
	${_kubectl} delete pods --all -n capk-system
}

function kubevirtci::install() {
	export MANIFEST_IMG="registry:5000/capk-manager-amd64"
	export MANIFEST_TAG="dev"
	make generate-manifests
	${_kubectl} kustomize config/kubevirtci | ${_kubectl} delete -f - || true
	${_kubectl} kustomize config/kubevirtci | ${_kubectl} apply -f -
	${_kubectl} wait -n capk-system --for=condition=Available=true deployment/capk-controller-manager --timeout=10m
}

function kubevirtci::generate_kubeconfig() {
        make clusterkubevirtadm-linux
        bin/clusterkubevirtadm-linux-amd64 apply credentials --namespace ${TENANT_CLUSTER_NAMESPACE} 
        bin/clusterkubevirtadm-linux-amd64 get kubeconfig --namespace=${TENANT_CLUSTER_NAMESPACE} --output-kubeconfig=kubeconfig-e2e
        sed -i -r 's/127.0.0.1:[0-9]+/192.168.66.101:6443/g' kubeconfig-e2e
}

function kubevirtci::create_cluster() {
	export NODE_VM_IMAGE_TEMPLATE=quay.io/capk/ubuntu-container-disk:20.04
	export IMAGE_REPO=k8s.gcr.io
	export CRI_PATH="/var/run/containerd/containerd.sock"
	oc create secret generic external-infra-kubeconfig -n capk-system --from-file=kubeconfig=kubeconfig-e2e --from-literal=namespace=${TENANT_CLUSTER_NAMESPACE}
	$CLUSTERCTL_PATH generate cluster ${TENANT_CLUSTER_NAME} --kubernetes-version v1.21.0 --control-plane-machine-count=1 --worker-machine-count=1 --from templates/cluster-template-ext-infra.yaml | ${_kubectl} apply -f -
}

function kubevirtci::kubectl_tenant {
    vms_list=$(${_kubectl} get vm -n ${TENANT_CLUSTER_NAMESPACE} --no-headers -o custom-columns=":metadata.name")
    for vm in $vms_list
    do
	if [[ "$vm" == ${TENANT_CLUSTER_NAME}-control-plane* ]]; then
            control_plane_vm_name=$vm
	fi
    done
    if [ -n "${control_plane_vm_name}" ]; then
  	echo "Found control plane VM: ${control_plane_vm_name} in namespace ${TENANT_CLUSTER_NAMESPACE}"
    else
  	echo "control-plane vm is not found in namespace ${TENANT_CLUSTER_NAMESPACE} (looking for regex ${TENANT_CLUSTER_NAME}-control-plane*)"
	exit 1
    fi
    ${_default_virtctl_path} port-forward -n ${TENANT_CLUSTER_NAMESPACE} vm/${control_plane_vm_name} 64443:6443 > /dev/null 2>&1 &
    trap 'kill $(jobs -p) > /dev/null 2>&1' EXIT
    rm -f .${TENANT_CLUSTER_NAME}-kubeconfig
    $CLUSTERCTL_PATH get kubeconfig ${TENANT_CLUSTER_NAME} -n ${TENANT_CLUSTER_NAMESPACE} > .${TENANT_CLUSTER_NAME}-kubeconfig
    sleep 0.1
    kubectl --kubeconfig .${TENANT_CLUSTER_NAME}-kubeconfig --insecure-skip-tls-verify --server https://localhost:64443 "$@"
}

kubevirtci::fetch_kubevirtci

case ${_action} in
"up")
	kubevirtci::up
	;;
"down")
	kubevirtci::down
	;;
"refresh")
	kubevirtci::build
	kubevirtci::refresh
	;;
"sync")
	kubevirtci::build
	kubevirtci::install
	;;
"kubeconfig")
	kubevirtci::kubeconfig
	;;
"kubectl")
	${_kubectl} "$@"
	;;
"kubectl-tenant")
	kubevirtci::kubectl_tenant "$@"
	;;
"virtctl")
	${_default_virtctl_path} "$@"
	;;
"ssh-infra")
	$_ssh_infra "$@"
	;;
"ssh-tenant")
	kubevirtci::ssh_tenant "$@"
	;;
"clusterctl")
	$CLUSTERCTL_PATH "$@"
	;;
"create-cluster")
	kubevirtci::generate_kubeconfig
	kubevirtci::create_cluster
	;;
"help")
	kubevirtci::usage
	;;
*)
	echo "Error: Unknown kubevirtci command"
	echo ""
	kubevirtci::usage
	exit 1
	;;
esac
